---
title: "racoon_clip processing report"
author: "Melina Klostermann"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    toc_float: TRUE
    toc: TRUE
    number_sections: yes
    fig_caption: yes
    cache: no
params:
  config: "config"
  output_dir: "output_dir" 
  snake_dir: "snake_dir"
  workflow_type: "workflow_type"

---

<style>
body {
  font-size: 16px;
}
</style>

```{r setup, include=FALSE}
require("knitr")
knitr::opts_chunk$set(warning=FALSE, message=FALSE, eval = TRUE, cache = F, echo = FALSE,  cache.lazy = FALSE,  dpi= 20, fig.width = 20, fig.height = 10, crop = NULL) #, fig.pos = "!H", out.extra = ""
# options(knitr.table.format = "html")

# Params for direct run
# local path on MAC
# params$snake_dir <- "/Users/melinaklostermann/Documents/projects/racoon_clip/racoon_clip/racoon_clip"
# # test eCLIP
# params$output_dir <- "/Users/melinaklostermann/Documents/projects/racoon_clip/racoon_clip/tests/report_test/test_report_eCLIP"
# params$config <- read_yaml("/Users/melinaklostermann/Documents/projects/racoon_clip/racoon_clip/tests/report_test/inputs_for_report_test/eCLIP/config_test_report_eCLIP.yaml") %>% unlist()


source(paste0(params$snake_dir, "/workflow/rules/theme_html.R"))
library(ggplot2)
theme_set(theme_html())
```

```{r libraries}
library(tidyverse)
library(yaml)
library(knitr)
library(kableExtra)
# library(gridExtra)
# library(grid)


```

```{r color_scheme}
# Define consistent color scheme for read processing stages
# Using a color palette with distinct colors for visualization consistency
racoon_colors <- c(
  "raw reads" = "#440154",              # Dark purple
  "reads" = "#440154",                  # Dark purple (underscore version)
  "raw_reads" = "#440154",              # Raw reads with underscore
  "filtered reads" = "#5B2C87",         # Medium-dark purple (between raw and trimmed)
  "filtered_reads" = "#5B2C87",         # Medium-dark purple (underscore version)
  "trimmed reads" = "#6A51A3",          # Medium purple
  "trimmed_reads" = "#6A51A3",          # Medium purple (underscore version)
  "mapped reads" = "#3B528B",           # Blue purple
  "mapped_reads" = "#3B528B",           # Blue purple (underscore version)
  "uniquely mapped reads" = "#21908C",  # Teal
  "uniquely_mapped_reads" = "#21908C",  # Teal (underscore version)
  "crosslink events (= deduplicated reads)" = "#E74C3C",     # Medium red (crosslink events)
  "deduplicated_reads" = "#E74C3C",     # Medium red (underscore version)
  "crosslinked nucleotides" = "#E67E22", # Orange (crosslinked nucleotides)
  "crosslinked_nucleotides" = "#E67E22", # Orange (underscore version)
  "peaks" = "#F1C40F"                   # Yellow
)

```

# Overview of steps performed

```{r display_workflow_type, results='asis'}
# Set workflow_type with fallback to "crosslinks" if not specified or NA
workflow_type <- params$workflow_type
if (is.null(workflow_type) || is.na(workflow_type) || workflow_type == "workflow_type") {
  workflow_type <- "crosslinks"
}

if(workflow_type == "peaks"){
cat("**racoon_clip peaks** was used.")
} else {
cat("**racoon_clip crosslinks** was used.")
}


```

\newline
\newline

```{r display_workflow_graphic, echo=FALSE, out.width="70%"}
include_graphics(paste0(params$snake_dir, "/workflow/rules/racoon_clip_workflow_2.0.png"))

```

\newline
\newline



# Configurations {.tabset}

Here is a summary of the settings you have chosen for this analysis.

```{r config}
#getwd()

config_default <- yaml.load_file(paste0(params$snake_dir, "/config/config.yaml")) %>%
  map_dfr(., ~.x) %>%
  t(.) %>%
  as.data.frame()
#config <- yaml.load_file(params$config) %>% map_dfr(., ~.x) %>% t(.) %>% as.data.frame(.)
config <-  params$config %>% map_dfr(~.x) %>% as.data.frame(.) %>% t(.)

#params$snake_dir

colnames(config_default) <- c("config")
colnames(config) <- c("config")

# colnames(config)
n <- which(!(rownames(config_default) %in% rownames(config)))

add <- data.frame(config = config_default[n,])
rownames(add) <- rownames(config_default)[n]


config <- rbind(config, add)
#kable(config)
# config
dir <- config["wdir",]

# Create directory for saving plots
plots_dir <- paste0(dir, "/results/Report_plots")
if (!dir.exists(plots_dir)) {
  dir.create(plots_dir, recursive = TRUE)
}

dir <- as.character(dir)

```

```{r what_to_run}
demult <- as.logical(config["demultiplex",])
trim <- as.logical(config["adapter_trimming",])
qual_bc <- as.logical(config["quality_filter_barcodes",]) 
dedup <- as.logical(config["deduplicate",]) 
no_trim <- !any(demult, trim, qual_bc)
only_trim <- ((!demult) && trim)
qual_bc_no_demult <- ((!demult) && qual_bc )
mir <- config["experiment_type",] == "miReCLIP"

# Check if we're running peaks workflow
peaks <- (params$workflow_type == "peaks")

# Check if FastQ Screen is enabled
fastq_screen_enabled <- FALSE
if ("fastqScreen" %in% rownames(config)) {
  fastq_screen_enabled <- as.logical(config["fastqScreen",])
  if (is.na(fastq_screen_enabled)) {
    fastq_screen_enabled <- (config["fastqScreen",] == "True" || config["fastqScreen",] == "true")
  }
}

if(config["experiment_type",] == "noBarcode_noUMI"){
  dedup <- FALSE}


```

## Input files
```{r input_files_table}

# df <- data.frame(parameter = c("configfile", "infiles", "barcodes_fasta", "gtf", "genome_fasta"), file = c(params$config, config[c("infiles", "barcodes_fasta", "gtf", "genome_fasta"),]))
df <- config[c(
  "infiles",
  "barcodes_fasta", 
  "gtf", 
  "genome_fasta",
  "fastqScreen_config"
), ] %>% as.data.frame(.)

rownames(df) <- c("infiles", "barcodes_fasta", "gtf", "genome_fasta", "fastqScreen_config")
colnames(df) <- "Input"

kable(df, caption = "Input files and reference data used in the analysis") %>% kable_styling(bootstrap_options = "striped", full_width = TRUE) %>% scroll_box(width = "100%")
```

## Options
```{r options_table}
t <- data.frame(config[c(
  "workflow_type",
  "demultiplex",
  "adapter_trimming", 
  "trim3",
  "quality_filter_barcodes", 
  "encode", 
  "deduplicate",
  "fastqScreen"
), ])
rownames(t) <- c(
  "workflow_type",
  "demultiplex",
  "adapter_trimming", 
  "trim3",
  "quality_filter_barcodes", 
  "encode", 
  "deduplicate",
  "fastqScreen"
)
colnames(t) <- "Option"
# Convert entire column to character first, then convert True/False to uppercase
t$Option <- as.character(t$Option)
t$Option <- sapply(t$Option, function(x) {
  if (tolower(as.character(x)) %in% c("true", "false")) {
    return(toupper(as.character(x)))
  } else {
    return(as.character(x))
  }
})
kable(t, caption = "Analysis workflow options and settings") %>% kable_styling(bootstrap_options = "striped", full_width = TRUE) %>% scroll_box(width = "100%")
```

## Barcode settings
```{r barcode_settings_table}
t <- data.frame(config[c("barcodeLength", "minBaseQuality", "umi1_len", "umi2_len","total_barcode_len", "samples", "encode", "encode_umi_length"),])
rownames(t) <- c("barcodeLength", "minBaseQuality", "umi1_len", "umi2_len","total_barcode_len", "samples", "encode", "encode_umi_length")
colnames(t) <- "Setting"
# Convert True/False to uppercase for display
t$Setting <- sapply(t$Setting, function(x) {
  if (is.logical(x)) {
    return(toupper(as.character(x)))
  } else if (tolower(as.character(x)) %in% c("true", "false")) {
    return(toupper(as.character(x)))
  } else {
    return(as.character(x))
  }
})
kable(t, caption = "Barcode and UMI configuration parameters") %>% kable_styling(bootstrap_options = "striped", full_width = TRUE) %>% scroll_box(width = "100%")
```

## Read filter
```{r read_filter_settings}
t <- data.frame(config[c("min_read_length"),])
rownames(t) <- ("min_read_length")
colnames(t) <- "Setting"
kable(t, caption = "Read length filtering parameters") %>% kable_styling(bootstrap_options = "striped", full_width = TRUE) %>% scroll_box(width = "100%")
```

## Peakcalling
```{r peakcalling_settings}
t <- data.frame(config[c("morePureclipParameters"),])
rownames(t) <- ("morePureclipParameters")
colnames(t) <- "Setting"
kable(t, caption = "Peak calling parameters for Pureclip") %>% kable_styling(bootstrap_options = "striped", full_width = TRUE) %>% scroll_box(width = "100%")
```

## Alignment setting (STAR)
```{r alignment_settings_star}
t <- data.frame(config[c("read_length", "outFilterMismatchNoverReadLmax", "outFilterMismatchNmax", "outFilterMultimapNmax", "outReadsUnmapped",  "outSJfilterReads", "moreSTARParameters"),])
rownames(t) <- c("read_length", "outFilterMismatchNoverReadLmax", "outFilterMismatchNmax", "outFilterMultimapNmax", "outReadsUnmapped",  "outSJfilterReads", "moreSTARParameters")
colnames(t) <- "Setting"
kable(t, caption = "STAR alignment parameters and settings") %>% kable_styling(bootstrap_options = "striped", full_width = TRUE) %>% scroll_box(width = "100%")

```

## Experimental groups
```{r check_groups_file}
gf <- file.exists(as.character(config["experiment_group_file",]))

```

```{r display_groups, eval=gf}
groups <- read.table(as.character(config["experiment_group_file",]))
colnames(groups) <- c("Group", "Sample")

kable(groups, caption = "Experimental groups and sample assignments") %>% kable_styling(bootstrap_options = "striped", full_width = TRUE) %>% scroll_box(width = "100%")

```

```{r no_groups_message, eval = !gf, results = 'asis'}
cat(paste("No groups specified. We will combine all samples for you."))
```


# {-}



# {-}



# Input sequencing files

```{r input_sequencing_files, eval=demult}
# If demultiplexed, show only the input file
name_raw_fasta <- strsplit(as.character(config["infiles",]), "/") %>% unlist(.)
l <- length(name_raw_fasta)
name_raw_fasta <- name_raw_fasta[[l]] %>% unlist(.)
name_raw_fasta <- gsub(".fastq.gz","", as.character(name_raw_fasta), fixed = T)  %>% unlist(.) %>% .[1]

# Read FastQC data
fastqc_data_file <- paste0(dir,"/results/fastqc/raw/", name_raw_fasta, "_fastqc/fastqc_data.txt")

if (file.exists(fastqc_data_file)) {
  fastqc_data <- read_delim(fastqc_data_file, 
                            delim = "\t", 
                            skip = 2, 
                            n_max = 10,
                            show_col_types = FALSE)
  
  # Extract Total Sequences (row 4) and Sequence length (row 7)
  total_seqs <- fastqc_data$Value[4]
  seq_length <- fastqc_data$Value[7]
  
  # Create table with just "input" as name
  input_table <- data.frame(
    Sample = "input",
    `Total Sequences` = format(as.numeric(total_seqs), big.mark = ",", scientific = FALSE),
    `Sequence Length` = seq_length,
    check.names = FALSE
  )
  
  kable(input_table, caption = "Input sequencing file summary") %>% kable_styling(bootstrap_options = "striped", full_width = TRUE) %>% scroll_box(width = "100%")
}
```

```{r barcode_file, eval=demult}
# Read and parse barcode fasta file
barcode_file <- as.character(config["barcodes_fasta",])
barcode_lines <- readLines(barcode_file)

# Extract sample names (lines starting with >) and sequences (following lines)
sample_names <- c()
barcodes <- c()

for (i in seq_along(barcode_lines)) {
  if (grepl("^>", barcode_lines[i])) {
    # Remove the ">" prefix
    sample_names <- c(sample_names, sub("^>", "", barcode_lines[i]))
    # Get the sequence from the next line
    if (i < length(barcode_lines)) {
      barcodes <- c(barcodes, barcode_lines[i + 1])
    }
  }
}

# Create table
barcode_table <- data.frame(
  `Sample Name` = sample_names,
  `Barcode` = barcodes,
  check.names = FALSE
)

kable(barcode_table, caption = "Sample barcodes used for demultiplexing") %>% kable_styling(bootstrap_options = "striped", full_width = TRUE)
```

```{r input_sequencing_files_multi, eval=!demult}
# If not demultiplexed, load the fastqc_report_raw from multiqc
fastqc_report_raw <- read_delim(paste0(dir,"/results/fastqc/raw/multiqc_data/multiqc_fastqc.txt"), delim="\t")

input_table <- data.frame(
  Sample = fastqc_report_raw$Sample,
  `Total Sequences` = format(as.numeric(fastqc_report_raw$`Total Sequences`), big.mark = ",", scientific = FALSE),
  `Sequence Length` = round(fastqc_report_raw$avg_sequence_length, digits = 1)
) %>% 
  arrange(as.character(Sample))

kable(input_table, caption = "Input sequencing files summary") %>% kable_styling(bootstrap_options = "striped") %>% scroll_box(width = "100%")
```


# Quality control of raw files 

Initial quality control of the raw sequencing file is performed with FastQC. Here you can see the sequencing quality and content per base.

```{r raw_quality, eval = demult}
# get name of file
name_raw_fasta <- strsplit(as.character(config["infiles",]), "/") %>% unlist(.)
l <- length(name_raw_fasta)
name_raw_fasta <- name_raw_fasta[[l]] %>% unlist(.)
name_raw_fasta <- gsub(".fastq.gz","", as.character(name_raw_fasta), fixed = T)  %>% unlist(.) %>% .[1]

# images
include_graphics(paste0(dir,"/results/fastqc/raw/", name_raw_fasta, "_fastqc/Images/per_base_quality.png"))
include_graphics(paste0(dir,"/results/fastqc/raw/", name_raw_fasta, "_fastqc/Images/per_base_sequence_content.png"))


```


```{r raw_quality_demult, eval=!demult, dpi=100, include=FALSE, out.width="100%"}

fastqc_report_raw <- read_delim(paste0(dir,"/results/fastqc/raw/multiqc_data/multiqc_fastqc.txt"), delim="\t")
fastqc_report_t <- fastqc_report_raw[,c(1,5:8,11)] %>% 
  mutate(avg_sequence_length = round(avg_sequence_length, digits = 1)) %>%
  arrange(as.character(Sample))
         #Sample = substr(Sample,20,nchar(Sample)))

kable(fastqc_report_t, caption = "Quality metrics for all raw sequencing files") %>% kable_styling(bootstrap_options = "striped", full_width = TRUE) %>% scroll_box(width = "100%")



pbq <- list.files(path = paste0(dir,"/results/fastqc/raw"), pattern = "\\per_base_quality.png$", recursive = TRUE, full.names = T) 
p <- nchar(paste0(dir,"/results/fastqc/raw/"))+1
n <- nchar("/Images/per_base_quality.png")
titles_pbq <- lapply(pbq, function(x) substr(x, p, nchar(x)-n-7 ))
# titles_pbq

pbsc <- list.files(path = paste0(dir,"/results/fastqc/raw"), pattern = "\\per_base_sequence_content.png$", recursive = TRUE, full.names = T)

# list.files(path = paste0(dir,"/results/fastqc/samples_after_demultiplexing_or_trimming"), pattern = "\\sequence_length", recursive = TRUE, full.names = T)

# pbq <- pbq %>% map(~png::readPNG(.x, native = F) %>% rasterGrob )
# pbsc <- pbsc %>% map(~png::readPNG(.x, native = F) %>% rasterGrob )
# titles_pbq <- titles_pbq %>% map(~ggpubr::text_grob(.x))
# 
# plots <- rbind(unlist(titles_pbq), unlist(pbq), unlist(pbsc)) %>% as.list()
# 
# marrangeGrob(grobs = plots, nrow = 1, ncol =3)  

```

```{r quality_scores_header, eval=!demult, results='asis'}
cat("## Quality scores across all bases {.tabset}\n")
```

```{r raw_quality_plots_loop, eval=!demult, out.width="100%", dpi = 100, results = "asis"}

for(i in 1:length(pbq)){
  cat("\n###", titles_pbq[[i]], "{-}\n")
  cat( paste0("![](", pbq[[i]], ") \n "))
}

```

## {-}

```{r sequence_content_header, eval=!demult, results='asis'}
cat("## Sequence content over all bases {.tabset}\n")
```

```{r raw_sequence_content_loop, eval=!demult, out.width="100%", dpi = 100, results = "asis"}

for(i in 1:length(pbq)){
  cat("\n### ", titles_pbq[[i]], "{-}\n")
  cat( paste0("![](", pbsc[[i]], ") \n"))
}

```

## {-}

**Note:** In CLIP-seq data, it is normal to observe an enrichment of thymine (T) nucleotides at the crosslink position, which occurs immediately following the barcode and UMI sequences. This T-enrichment is a characteristic signature of UV-induced crosslinking.



```{r fastq_screen_header, eval = fastq_screen_enabled, results = 'asis'}
cat("# FastQ Screen contamination check \n")
cat("FastQ Screen was used to check for potential contamination from different organisms. The plot shows the percentage of reads mapping to each reference genome.\n")
```


```{r fastq_screen_read_data, eval = fastq_screen_enabled && file.exists(paste0(dir,"/results/fastqscreen_multi/fastqscreen_multiqc_data/multiqc_fastq_screen.txt"))}
# Read the FastQ Screen multiqc data
fastqscreen_file <- paste0(dir,"/results/fastqscreen_multi/fastqscreen_multiqc_data/multiqc_fastq_screen.txt")

# Read header line separately to extract column names
header_line <- readLines(fastqscreen_file, n = 1)
col_names_raw <- strsplit(header_line, "\t")[[1]]

# Read the data without column names
fastqscreen_data <- read_delim(fastqscreen_file, delim="\t", col_names = FALSE, skip = 1, show_col_types = FALSE)

# Identify genome-specific columns (pairs of "counts" and "percentage")
# Structure: Sample, total_reads, [genome counts, genome percentage]*, No hits counts, No hits percentage
genome_cols <- col_names_raw[!col_names_raw %in% c("Sample", "total_reads", "No hits counts", "No hits percentage")]

# For each genome, we have two columns: "genome counts" and "genome percentage"
# Extract unique genome names by removing " counts" and " percentage" suffixes
genome_names <- unique(gsub(" (counts|percentage)$", "", genome_cols))

# Create clean column names by combining genome names with metric types
clean_col_names <- c("Sample", "total_reads")
for (genome in genome_names) {
  clean_col_names <- c(clean_col_names, paste0(genome, "_counts"), paste0(genome, "_percentage"))
}
# Add "No hits" columns at the end
clean_col_names <- c(clean_col_names, "NoHits_counts", "NoHits_percentage")

# Assign clean column names to the data
colnames(fastqscreen_data) <- clean_col_names

# Clean up sample names (remove _screen suffix if present)
fastqscreen_data$Sample <- gsub("_screen$", "", fastqscreen_data$Sample)

# Create table with only percentage columns for display
percentage_col_indices <- grep("percentage$", col_names_raw)
percentage_col_names <- col_names_raw[c(1, percentage_col_indices)]  # Sample + percentage columns
fastqscreen_report <- fastqscreen_data[, c(1, percentage_col_indices)]
colnames(fastqscreen_report) <- percentage_col_names
fastqscreen_report$Sample <- gsub("_screen$", "", fastqscreen_report$Sample)

# Identify percentage columns for plotting (those ending with "_percentage")
percentage_cols <- grep("_percentage$", names(fastqscreen_data), value = TRUE)
genome_names_plot <- gsub("_percentage$", "", percentage_cols)

# Create a long format data frame for plotting (tidyr and stringr already loaded via tidyverse)
# Extract percentage data for each genome
percentage_cols <- grep("_percentage$", names(fastqscreen_data), value = TRUE)
plot_data <- fastqscreen_data %>%
  select(Sample, all_of(percentage_cols)) %>%
  pivot_longer(cols = all_of(percentage_cols), 
               names_to = "Genome", 
               values_to = "Percentage") %>%
  mutate(Genome = gsub("_percentage$", "", Genome))

```

```{r fastq_screen_summary_table, eval = fastq_screen_enabled && file.exists(paste0(dir,"/results/fastqscreen_multi/fastqscreen_multiqc_data/multiqc_fastq_screen.txt"))}
# Display summary table
kable(fastqscreen_report, caption = "Contamination screening results showing percentage of reads mapping to different reference genomes") %>% kable_styling(bootstrap_options = "striped", full_width = TRUE) %>% scroll_box(width = "100%")
```


```{r fastq_screen_plot, eval = fastq_screen_enabled && file.exists(paste0(dir,"/results/fastqscreen_multi/fastqscreen_multiqc_data/multiqc_fastq_screen.txt")), dpi=100, out.width="100%"}
# Create stacked bar plot
library(ggplot2)

p <- ggplot(plot_data, aes(x = Sample, y = Percentage, fill = Genome)) +
  geom_bar(stat = "identity", position = "dodge", color = "black") +
  geom_text(aes(label = ifelse(Percentage > 0, sprintf("%.1f", Percentage), "")), 
            position = position_dodge(width = 0.9), 
            hjust = -0.1, 
            size = 7) +
  theme(axis.text.x = element_text(angle = 0, hjust = 0.5),
        axis.text.y = element_text(size = rel(0.9)),
        legend.position = "top",
        legend.title = element_blank()) +
  labs(x = "Sample",
       y = "Mapping Percentage (%)",
       fill = "Genome") +
  xlab("Sample") +
  ylab("Mapping Percentage (%)") +
  coord_flip() +
  scale_y_continuous(expand = expansion(mult = c(0, 0.15))) +
  scale_fill_viridis_d()
print(p)
ggsave(filename = paste0(plots_dir, "/FastQ_Screen.pdf"), plot = p, width = 14, height = 8)
```



```{r quality_filter_header, eval=qual_bc, results = 'asis'}
cat(" \n")
cat(paste("# Quality filtering in barcode region \n Sequences are filtered for a **minimum base quality of", config["minBaseQuality",], "** within the barcode region to ensure correct sample and duplicate assignment.\n"))
cat(" \n")
```

```{r barcode_filter_setup}
bc_filter_one_file <- (demult && qual_bc)
bc_filter_multi_file <- ((!demult) && qual_bc)

```


```{r barcode_filter1, eval=demult}
fastqc_report_raw <- read_delim(paste0(dir,"/results/fastqc/raw/", name_raw_fasta, "_fastqc/fastqc_data.txt"),
  delim = "\t", 
  skip = 2, 
  n_max = 10
)
fastqc_report_filtered <- read_delim(paste0(dir, "/results/fastqc/filtered/filtered_fastqc/fastqc_data.txt"),
  delim = "\t", 
  skip = 2, 
  n_max = 10
)
read_numbers <- data.frame( steps = c("raw", "after quality filter on barcode"),
                            `number of reads` = c(
                              format(as.numeric(fastqc_report_raw$Value[4]), big.mark = ",", scientific = FALSE),
                              format(as.numeric(fastqc_report_filtered$Value[4]), big.mark = ",", scientific = FALSE)
                            ),
                            check.names = FALSE)

kable(read_numbers, caption = "Read numbers before and after the quality filtering step") %>% kable_styling(bootstrap_options = "striped", full_width = TRUE) %>% scroll_box(width = "100%")

```

```{r barcode_filter1_multi, eval=qual_bc_no_demult }

fastqc_report_filtered <- read_delim(paste0(dir,"/results/fastqc/filtered/multiqc_data/multiqc_fastqc.txt"), delim="\t")

read_numbers <- data.frame( Sample = fastqc_report_raw$Sample,
                            "Raw reads" = format(as.numeric(fastqc_report_raw$`Total Sequences`), big.mark = ",", scientific = FALSE), 
                            "Filtered reads" = format(as.numeric(fastqc_report_filtered$`Total Sequences`), big.mark = ",", scientific = FALSE),
                            check.names = FALSE) %>% 
  arrange(as.character(Sample))

kable(read_numbers, caption = "Read numbers before and after the quality filtering step") %>% kable_styling(bootstrap_options = "striped", full_width = TRUE) %>% scroll_box(width = "100%")

```


```{r quality_after_filter_header, eval=qual_bc, results = 'asis'}
cat("## Sequencing quality and content per base after the quality filtering step \n")
```

```{r barcode_filter2, eval=bc_filter_one_file, results = 'asis'}
cat("### Quality scores across all bases \n")
include_graphics(paste0(dir,"/results/fastqc/filtered/filtered_fastqc/Images/per_base_quality.png"))
cat(" \n")
cat(" \n")
cat(" \n")
cat("\n ### Sequence content over all bases \n")
cat(" \n")
include_graphics(paste0(dir,"/results/fastqc/filtered/filtered_fastqc/Images/per_base_sequence_content.png"))
cat(" \n")

```

```{r quality_scores_tabset_header, eval=qual_bc_no_demult , results = 'asis'}
cat("### Quality scores across all bases {.tabset} \n")
```


```{r barcode_filter2_multi, eval=qual_bc_no_demult , out.width="100%", dpi = 100, results = "asis"}

pbq <- list.files(path = paste0(dir,"/results/fastqc/filtered"), pattern = "\\per_base_quality.png$", recursive = TRUE, full.names = T) 
p <- nchar(paste0(dir,"/results/fastqc/filtered/")) + 1
n <- nchar("/Images/per_base_quality.png")
titles_pbq <- lapply(pbq, function(x) substr(x, p ,nchar(x)-n-7 ))
# titles_pbq

pbsc <- list.files(path = paste0(dir,"/results/fastqc/filtered"), pattern = "\\per_base_sequence_content.png$", recursive = TRUE, full.names = T)

# list.files(path = paste0(dir,"/results/fastqc/samples_after_demultiplexing_or_trimming"), pattern = "\\sequence_length", recursive = TRUE, full.names = T)

# pbq <- pbq %>% map(~png::readPNG(.x, native = F) %>% rasterGrob )
# pbsc <- pbsc %>% map(~png::readPNG(.x, native = F) %>% rasterGrob )
# titles_pbq <- titles_pbq %>% map(~ggpubr::text_grob(.x))
# 
# plots <- rbind(unlist(titles_pbq), unlist(pbq), unlist(pbsc)) %>% as.list()
# 
# marrangeGrob(grobs = plots, nrow = 1, ncol =3)  


# pmap(list(a = titles_pbq, b = pbq, c = pbsc), function(a,b,c) print(marrangeGrob(grobs = list(b,c), title = a, nrow=2)   ))

```





```{r filtered_quality_plots_loop, out.width="100%", dpi = 100, results = 'asis', eval=qual_bc_no_demult }
for(i in 1:length(pbq)){
  cat("####", titles_pbq[[i]], "{-}\n")
  cat( paste0("![](", pbq[[i]], ") \n"))
  cat("\n")
}
cat("### {-} \n")

```

```{r sequence_content_tabset_header, eval=qual_bc_no_demult , results = 'asis'}
cat("\n")
cat(" \n")
cat("### Sequence content over all bases {.tabset}")
cat("\n")
```

```{r filtered_sequence_content_loop, out.width="100%", dpi = 100, results = "asis", eval=qual_bc_no_demult }
for(i in 1:length(pbsc)){
  cat("####", titles_pbq[[i]], "{-}\n")
  cat( paste0("![](", pbsc[[i]], ") \n"))
  cat("\n")
}

```

```{r sequence_content_tabset_end, eval=qual_bc_no_demult , results = 'asis'}
cat("### {-}")
```

```{r old_filter_variables}
# demult <- (config["demuliplex",] == "TRUE")
# trim <- (config["adapter_trimming",] == "TRUE")
# qual_bc <- (config["quality_filter_barcodes",] == "TRUE")
```



```{r demultiplexing_header, eval=demult, results = 'asis'}
cat("# Demultiplexing and quality control of individual samples \n
Samples are demultiplexed with Flexbar and adapters are trimmed in the same step.")

```


```{r demultiplexed_samples, out.width="100%", dpi = 100, results = "asis", eval=demult}
fastqc_report_filtered <- read_delim(paste0(dir,"/results/fastqc/samples_after_demultiplexing_or_trimming/multiqc_data/multiqc_fastqc.txt"), delim="\t")
fastqc_report_filtered_t <- fastqc_report_filtered[,c(1,5:7,11)] %>% 
  #mutate(avg_sequence_length = round(avg_sequence_length, digits = 1)) %>% 
  mutate(Sample = gsub("flexbarOut_barcode_", "", Sample)) %>%
  arrange(as.character(Sample))
         #Sample = substr(Sample,20,nchar(Sample)))

kable(fastqc_report_filtered_t, caption = "Quality metrics for demultiplexed and adapter-trimmed samples") %>% kable_styling(bootstrap_options = "striped", full_width = TRUE) %>% scroll_box(width = "100%")


# include_graphics(paste0(dir,"/results/fastqc/samples_after_demultiplexing_or_trimming/multiqc_plots/png/mqc_fastqc_per_base_sequence_quality_plot_1.png"))
# include_graphics(paste0(dir,"/results/fastqc/samples_after_demultiplexing_or_trimming/multiqc_plots/png/mqc_fastqc_per_sequence_gc_content_plot_Percentages.png"))
# 
# include_graphics(paste0(dir,"/results/fastqc/samples_after_demultiplexing_or_trimming/multiqc_plots/png/mqc_fastqc_sequence_length_distribution_plot_1.png"))


# pbq <- list.files(path = paste0(dir,"/results/fastqc/samples_after_demultiplexing_or_trimming"), pattern = "\\per_base_quality.png$", recursive = TRUE, full.names = T) 
# p <- nchar(paste0(dir,"/results/fastqc/samples_after_demultiplexing_or_trimming/"))+1
# n <- nchar("/Images/per_base_quality.png")
# titles_pbq <- lapply(pbq, function(x) substr(x, p, nchar(x)-n-7 ))
# # titles_pbq
# 
# pbsc <- list.files(path = paste0(dir,"/results/fastqc/samples_after_demultiplexing_or_trimming"), pattern = "\\per_base_sequence_content.png$", recursive = TRUE, full.names = T)
# 
# # list.files(path = paste0(dir,"/results/fastqc/samples_after_demultiplexing_or_trimming"), pattern = "\\sequence_length", recursive = TRUE, full.names = T)
# 
# # pbq <- pbq %>% map(~png::readPNG(.x, native = F) %>% rasterGrob )
# # pbsc <- pbsc %>% map(~png::readPNG(.x, native = F) %>% rasterGrob )
# # titles_pbq <- titles_pbq %>% map(~ggpubr::text_grob(.x))
# # 
# # plots <- rbind(unlist(titles_pbq), unlist(pbq), unlist(pbsc)) %>% as.list()
# # 
# # marrangeGrob(grobs = plots, nrow = 1, ncol =3)  
# 
# for(i in 1:length(pbq)){
#   cat(paste0("\n  **", titles_pbq[[i]], "** \n"))
#   cat( paste0("![](", pbq[[i]], ") \n"))
#   cat( paste0("![](", pbsc[[i]], ") \n"))
# }

# pmap(list(a = titles_pbq, b = pbq, c = pbsc), function(a,b,c) print(marrangeGrob(grobs = list(b,c), title = a, nrow=2)   ))

  
```

```{r barcode_distances_header, eval=F, results = 'asis'}
# asis_output("# Adapter trimming \\n")
print("## Mutations in barcodes /n Mutations can occur during PCR amplification or read sequencing. Mutations within the gene sequence are dealt with during the star alignment step. However, mutations in the barcode sequence can cause the read to be assigned to the wrong sample. As a result, a read with a single or multiple mutated barcode will not be assigned to any sample. Here is an overview of the distance between the detected barcodes and the specified sample barcodes.")
```

```{r barcode_distances, out.width="100%", eval=FALSE}
barcodes_found <- read_table(paste0(dir,"/results/barcode_filter/barcodes_detected.txt"), col_names = c("n", "barcode"))


barcodes_fasta <- read_table(as.character(config["barcodes_fasta",]), col_names = F)
barcodes_fasta <- data.frame(sample = barcodes_fasta[c(1:nrow(barcodes_fasta) %% 2 != 0),],
                             barcode = barcodes_fasta[c(1:nrow(barcodes_fasta) %% 2 == 0),])
colnames(barcodes_fasta) <- c("sample", "barcode")


barcodes_fasta <- barcodes_fasta %>% mutate(., exp_barcode = substr(barcode, as.numeric(config["umi1_len",])+1, as.numeric(config["umi1_len",])+as.numeric(config["exp_barcode_len",]) ) )
kable(barcodes_fasta, caption = "sample barcodes") %>% kable_styling(bootstrap_options = "striped", full_width = TRUE) 

barcodes_found <- barcodes_found %>%
  rowwise %>%
  mutate( mismatch_0 = vcountPattern(barcode, barcodes_fasta$barcode, max.mismatch=0) %>% sum(),
          mismatch_1 = vcountPattern(barcode, barcodes_fasta$barcode, max.mismatch=1) %>% sum(),
          mismatch_2 = vcountPattern(barcode, barcodes_fasta$barcode, max.mismatch=2) %>% sum(),
          mismatch_3 = vcountPattern(barcode, barcodes_fasta$barcode, max.mismatch=3) %>% sum(),
          mismatch_4 = vcountPattern(barcode, barcodes_fasta$barcode, max.mismatch=4) %>% sum(),
          mismatch_5 = vcountPattern(barcode, barcodes_fasta$barcode, max.mismatch=5) %>% sum(),
          dist = case_when(mismatch_0 > 0 ~ 0,
                           mismatch_1 > 0 ~ 1,
                           mismatch_2 > 0 ~ 2,
                           mismatch_3 > 0 ~ 3,
                           mismatch_4 > 0 ~ 4,
                           mismatch_5 > 0 ~ 5,
                           ),
          # dist = factor(dist, levels = dist),
          barcode = factor(barcode, levels = barcode),
          dist = as.character(dist))  %>%
  arrange(dist)

head(barcodes_found)

ggplot(barcodes_found[c(1:100),], aes(x=barcode, y = n, fill = dist))+
  geom_col()+
  theme(text=element_text(size=50))+
  scale_fill_viridis_d()


ggplot(barcodes_found[ barcodes_found$dist != 0,], aes(x=barcode, y = log(n), fill = as.factor(dist)))+
  geom_col()+
  theme(text=element_text(size=50))+
  scale_fill_viridis_d()





```

# Adapter trimming

**Adapter Content Detection and Trimming:**  
If FastQC reports "No adapter content found" in the raw files, this indicates that adapter sequences were not detected by FastQC's automated detection. However, adapter trimming is still performed using FLEXBAR with the adapter sequences specified in your configuration file. If no file is provied, a default file is used, which contains standard Illumina and eCLIP adapters. 

The adapters are trimmed from the 3' end of the read (`--adapter-trim-end RIGHT`), with an allowed error of 0.1 (`--adapter-error-rate 0.1`). The adapter must overlap the read by at least 1nt (`--adapter-min-overlap 1`). Adapter trimming can be done in multiple cycles as specified by the user, here `r config["adapter_cycles",]` (adapterCycles, see configurations). Reads shorter than `r config["min_read_length",]` are discarded (min_read_length, see configurations).

UMIs are written into the read header with (`--umi-tags`). (If the data is from ENCODE, UMIs are already removed from the read and written to the beginning of the header. As umi-tools dedup, which is used here for deduplication, expects the UMI to be at the end of the read, encode: True can be specified to move the UMI from the beginning of the read header to the end (see configurations).)



```{r trim_read_numbers, eval=(!demult && trim)}
# Read numbers table for non-demultiplexed trimmed samples
# Load raw data if not already loaded
if (!exists("fastqc_report_raw")) {
  fastqc_report_raw <- read_delim(paste0(dir,"/results/fastqc/raw/multiqc_data/multiqc_fastqc.txt"), delim="\t", show_col_types = FALSE)
}

# Load filtered data if quality filtering was done
if (qual_bc && !exists("fastqc_report_filtered")) {
  fastqc_report_filtered <- read_delim(paste0(dir,"/results/fastqc/filtered/multiqc_data/multiqc_fastqc.txt"), delim="\t", show_col_types = FALSE)
}

# Load trimmed data
fastqc_report_trimmed <- read_delim(paste0(dir,"/results/fastqc/samples_after_demultiplexing_or_trimming/multiqc_data/multiqc_fastqc.txt"), delim="\t", show_col_types = FALSE)

# Create table with Raw, Filtered (if qual_bc), and Trimmed reads
if (qual_bc) {
  # If quality filtering was done, show all three columns
  trim_numbers <- data.frame(
    Sample = fastqc_report_raw$Sample,
    "Raw reads" = format(as.numeric(fastqc_report_raw$`Total Sequences`), big.mark = ",", scientific = FALSE),
    "Filtered reads" = format(as.numeric(fastqc_report_filtered$`Total Sequences`), big.mark = ",", scientific = FALSE),
    "Trimmed reads" = format(as.numeric(fastqc_report_trimmed$`Total Sequences`), big.mark = ",", scientific = FALSE),
    check.names = FALSE
  ) %>% arrange(as.character(Sample))
} else {
  # If no quality filtering, show only Raw and Trimmed
  trim_numbers <- data.frame(
    Sample = fastqc_report_raw$Sample,
    "Raw reads" = format(as.numeric(fastqc_report_raw$`Total Sequences`), big.mark = ",", scientific = FALSE),
    "Trimmed reads" = format(as.numeric(fastqc_report_trimmed$`Total Sequences`), big.mark = ",", scientific = FALSE),
    check.names = FALSE
  ) %>% arrange(as.character(Sample))
}

kable(trim_numbers, caption = "Read counts through quality filtering and adapter trimming steps") %>% kable_styling(bootstrap_options = "striped", full_width = TRUE) %>% scroll_box(width = "100%")
```

```{r trim_comparison_plot, eval=(!demult && trim), dpi=100}
# Create plot using the same data source as the table
# Create plot data by converting formatted numbers back to numeric
trim_plot_data <- trim_numbers
# Convert formatted strings back to numeric for plotting
for(i in 2:ncol(trim_plot_data)) {
  trim_plot_data[,i] <- as.numeric(gsub(",", "", trim_plot_data[,i]))
}

# Melt the data for plotting
trim_plot_data <- reshape2::melt(trim_plot_data, id.vars = "Sample")

if (qual_bc) {
  # Set factor levels (reversed for coord_flip)
  trim_plot_data$variable <- factor(trim_plot_data$variable, 
                                     levels = c("Trimmed reads", "Filtered reads", "Raw reads"))
  
  # Create plot
  p <- ggplot(trim_plot_data, aes(x = Sample, y = value, fill = variable)) +
    geom_col(position = "dodge", stat = "identity", color = "black") +
    geom_text(aes(label = scales::comma(value)), 
              position = position_dodge(width = 0.9), 
              hjust = -0.1, 
              size = 7) +
    theme(axis.text.x = element_text(angle = 0, hjust = 0.5),
          axis.text.y = element_text(size = rel(0.9)),
          legend.title = element_blank(),
          legend.position = "top") +
    ylab("Number of reads") +
    xlab("Sample") +
    coord_flip() +
    scale_y_continuous(labels = scales::comma, expand = expansion(mult = c(0, 0.15))) +
    scale_fill_manual(values = c("Trimmed reads" = unname(racoon_colors["trimmed_reads"]), 
                                "Filtered reads" = unname(racoon_colors["filtered_reads"]), 
                                "Raw reads" = unname(racoon_colors["raw_reads"])),
                      labels = c("Trimmed Reads", "Filtered Reads", "Raw Reads"))
} else {
  # Set factor levels (reversed for coord_flip)  
  trim_plot_data$variable <- factor(trim_plot_data$variable, 
                                     levels = c("Trimmed reads", "Raw reads"))
  
  # Create plot
  p <- ggplot(trim_plot_data, aes(x = Sample, y = value, fill = variable)) +
    geom_col(position = "dodge", stat = "identity", color = "black") +
    geom_text(aes(label = scales::comma(value)), 
              position = position_dodge(width = 0.9), 
              hjust = -0.1, 
              size = 7) +
    theme(axis.text.x = element_text(angle = 0, hjust = 0.5),
          axis.text.y = element_text(size = rel(0.9)),
          legend.title = element_blank(),
          legend.position = "top") +
    ylab("Number of reads") +
    xlab("Sample") +
    coord_flip() +
    scale_y_continuous(labels = scales::comma, expand = expansion(mult = c(0, 0.15))) +
    scale_fill_manual(values = c("Trimmed reads" = unname(racoon_colors["trimmed_reads"]), 
                                "Raw reads" = unname(racoon_colors["raw_reads"])),
                      labels = c("Trimmed Reads", "Raw Reads"))
}

print(p)
ggsave(filename = paste0(plots_dir, "/Adapter_trimming.pdf"), plot = p, width = 14, height = 8)
```

## Adapter content before trimming

Position of adapters found in the reads. If adapters are found early in the reads, this indicates over digestion of the samples.

```{r adapter_content_before_trimming, results='asis'}

if (qual_bc){
 # Quality filtered but not demultiplexed - check both multiqc_plots and multiqc_data locations
 f = paste0(dir,"/results/fastqc/filtered/filtered_fastqc/Images/adapter_content.png")

}else{
    # Raw data, not demultiplexed - check both multiqc_plots and multiqc_data locations
    f = paste0(dir,"/results/fastqc/*/Images/adapter_content.png")
}
    
    
if(file.exists(f)){
    include_graphics(f)
  }else{
    cat("\n \n  **No adapter content was detected in the raw files. **") }



```

```{r adapter_content_after_trimming_demult, eval=demult, results = 'asis'}
cat("## Adapter content after trimming \n")

if(file.exists(paste0(dir,"/results/fastqc/samples_after_demultiplexing_or_trimming/multiqc_plots/png/fastqc_adapter_content_plot.png"))){
  include_graphics(paste0(dir,"/results/fastqc/samples_after_demultiplexing_or_trimming/multiqc_plots/png/fastqc_adapter_content_plot.png"))
}else{
  cat("\n \n  **Trimming successful, no adapter contents left. **")
}

```


```{r adapter_content_after_trimming, eval=only_trim, results = 'asis'}
cat("## Adapter content after trimming \n")

if(file.exists(paste0(dir,"/results/fastqc/samples_after_demultiplexing_or_trimming/multiqc_plots/png/mqc_fastqc_adapter_content_plot_1.png"))){
  include_graphics(paste0(dir,"/results/fastqc/samples_after_demultiplexing_or_trimming/multiqc_plots/png/mqc_fastqc_adapter_content_plot_1.png"))
}else{
  cat("\n \n  **Trimming successful, no adapter contents left. **")
}

```

```{r no_trimming_message, eval = no_trim, results = 'asis'}
cat("No trimming has been performed.")
```

# Alignment

The genome annotation is indexed using STAR `--runMode genomeGenerate`. The merged file of chimeric reads is then aligned to the genome annotation using STAR `--runMode alignReads`. For STAR settings, see Configurations. The resulting bam files are indexed using samtools index.

```{r alignment_table_standard, eval=!mir }
star_out <- list.files(path = paste0(dir,"/results/aligned"), pattern = "*Log.final.out$", recursive = TRUE, full.names = T) %>% map(~read_delim(.x, delim="\t", col_names = c("type", "number")))

star_mir_out_names <-  list.files(paste0(dir,"/results/aligned"), pattern = "*Log.final.out$", recursive = TRUE) %>%
  gsub("chimeric_", "", . ) %>%
  gsub(".Log.final.out", "",  . )


names(star_out) <- star_mir_out_names 

r <- c(5,8,9,23,24,25,26,28:33)
star_out2 <- star_out %>% map(., ~.x[r,]) %>%
  map_dfr( ~.x$number) 


names <- star_out[[1]]$type[c(5,8,9,23,24,25,26,28:33)]
star_out2 <- star_out2 %>% as.data.frame(.)
rownames(star_out2) <- substr(names,1, nchar(star_out[[1]]$type)-2)

# star_out2 <- star_out2 %>%
#   arrange(as.character(Sample)) %>%
#   .[, r]

kable(star_out2, caption = "STAR alignment statistics for all samples") %>%
  kable_styling(bootstrap_options = "striped", full_width = FALSE) %>%
  column_spec(1, bold = TRUE) %>%
  row_spec(1:2, bold = TRUE, background = "#C8D9E8") %>%
  scroll_box(width = "100%", height = "500px")
```


```{r alignment_table_mirna, eval =mir}

star_out <- list.files(path = paste0(dir, "/results/aligned"), pattern = "*Log.final.out$", recursive = TRUE, full.names = T) %>% map(~ read_delim(.x, delim = "\t", col_names = c("type", "number")))

star_mir_out_names <-  list.files(paste0(dir,"/results/aligned"), pattern = "*Log.final.out$", recursive = TRUE) %>%
  gsub("chimeric_", "", . ) %>%
  gsub(".Log.final.out", "",  . )

names(star_out) <- star_mir_out_names 

r <- c(5,8,9,23,24,25,26,28:33)
star_out2 <- star_out %>% map(., ~.x[r,]) %>%
  map_dfr( ~.x$number) 


names <- star_out[[1]]$type[c(5,8,9,23,24,25,26,28:33)]
rownames(star_out2) <- substr(names,1, nchar(star_out[[1]]$type)-2)

# star_out2 <- star_out2 %>%
#   arrange(as.character(Sample)) %>%
#   .[, r]

kable(as.data.frame(star_out2), caption = "STAR alignment statistics for miRNA samples") %>%
  kable_styling(bootstrap_options = "striped", full_width = FALSE) %>%
  column_spec(1, bold = TRUE) %>%
  row_spec(1:2, bold = TRUE, background = "#C8D9E8") %>%
  scroll_box(width = "100%", height = "500px")
```

```{r alignment_plot, dpi=100 }
gg.df <- t(star_out2) %>% as.data.frame(.) %>% .[,c(1,2,6) ]

gg.df$Sample <- rownames(gg.df)
colnames(gg.df) <- c("reads",  "uniquely_mapped_reads", "mapped_reads", "Sample")


gg.df <- gg.df %>% mutate( reads = as.numeric(reads),
                           uniquely_mapped_reads = as.numeric(uniquely_mapped_reads),
                           mapped_reads = as.numeric(mapped_reads) + uniquely_mapped_reads
                           )

gg.df <- gg.df %>% reshape2::melt()

# Set factor levels to control order: reads first, then mapped, then uniquely mapped (reversed for coord_flip)
gg.df$variable <- factor(gg.df$variable, levels = c("uniquely_mapped_reads", "mapped_reads", "reads"))

# Convert values to numeric for plotting
gg.df$value <- as.numeric(gg.df$value)

read_col <- unname(racoon_colors[
  if (trim) "trimmed_reads"
  else if (qual_bc) "filtered_reads"
  else "raw_reads"
])


read_lab <- case_when(
  trim     ~ "Trimmed Reads",
  qual_bc  ~ "Filtered Reads",
  TRUE     ~ "Raw Reads"
)



p <- ggplot(gg.df, aes(x = Sample, y = value, fill = variable))+
  geom_col(position = "dodge", stat = "identity", color = "black")+
  geom_text(aes(label = scales::comma(value)), 
            position = position_dodge(width = 0.9), 
            hjust = -0.1, 
            size = 7)+
  theme(axis.text.x = element_text(angle = 0, hjust = 0.5),
        axis.text.y = element_text(size = rel(0.9)),
        legend.title = element_blank(),
        legend.position = "top")+
  ylab("Number of reads")+
  xlab("Sample")+
  coord_flip()+
  scale_y_continuous(labels = scales::comma, expand = expansion(mult = c(0, 0.15)))+
  scale_fill_manual(values = c("uniquely_mapped_reads" = unname(racoon_colors["uniquely_mapped_reads"]), 
                              "mapped_reads" = unname(racoon_colors["mapped_reads"]), 
                              "reads" = read_col), 
                    labels = c("Uniquely Mapped", "Mapped Reads", read_lab ))
print(p)
ggsave(filename = paste0(plots_dir, "/Alignment.pdf"), plot = p, width = 14, height = 8)

```


```{r deduplication_intro, eval=dedup, results = 'asis'}
# asis_output("# Adapter trimming \\n")
cat("# Deduplication \n
Reads are deduplicated with umi_tools dedup `--extract-umi-method read_id --method unique`.")
```

```{r dedup_comparison, eval=dedup}
# Create deduplication comparison table
# Get data from alignment (star_out2 has input reads and uniquely mapped)
# Get data from deduplication logs

umitools_out_temp <- list.files(path = paste0(dir,"/results/aligned"), pattern = "*out.duprm.log$", recursive = TRUE, full.names = T) %>%
  map(~read_delim(.x, delim="\t", skip = 57, col_names = c("invalue"), show_col_types = FALSE))

umitools_out_temp <- map(umitools_out_temp, ~mutate(.x, measure = substr(invalue, 29, nchar(invalue)) %>% strsplit(., split = ":")) )

umitools_out_temp = map(umitools_out_temp, ~mutate(.x,
 measure=modify_if(measure,
                           .p = is_empty,
                           .f = ~NA_character_))
)

umitools_out_temp <- map(umitools_out_temp, ~ rowwise(.x) %>%
  mutate(
    type = measure[[1]],
    number = measure[[length(measure)]]
  ) %>%
  .[(nrow(.) - 5):(nrow(.) - 2), ])

umitools_names <-  list.files(path = paste0(dir,"/results/aligned"), pattern = "*out.duprm.log$", recursive = TRUE) %>%
  gsub("chimeric_", "", . ) %>%
  gsub(".Aligned.sortedByCoord.out.duprm.log", "", . )

names(umitools_out_temp) <- umitools_names

# Extract input reads and deduplicated reads from umitools output
input_reads <- map_chr(umitools_out_temp, ~.x$number[1])
deduplicated_reads <- map_chr(umitools_out_temp, ~.x$number[2])

# Get uniquely mapped reads from star_out2 (row 2)
uniquely_mapped <- star_out2[2, ]

# Create comparison table
dedup_comparison <- data.frame(
  Sample = colnames(star_out2),
  "Uniquely Mapped Reads" = format(as.numeric(unlist(uniquely_mapped)), big.mark = ",", scientific = FALSE),
  "Deduplicated Reads" = format(as.numeric(deduplicated_reads), big.mark = ",", scientific = FALSE),
  check.names = FALSE
)

kable(dedup_comparison, caption = "Read counts from raw input through alignment and UMI-based deduplication") %>%
  kable_styling(bootstrap_options = "striped", full_width = FALSE) %>%
  column_spec(1, bold = TRUE) %>%
  scroll_box(width = "100%")
```



# Obtaining crosslinks

The (deduplicated) bam files are then converted to bed files using bedtools bamtobed. The reads are shifted 1nt upstream (5' direction) with bedtools shift -m 1 -p -1 because the UV crosslink should be positioned 1nt earlier. 
\n
To allow visualisation in a genome browser, the 1nt crosslink bed file is also converted to a .bigWig file using bedGraphToBigWig. These bigWig files are then merged with bigWigMerge by the experiment groups specified by the user.

```{r crosslinks_table_and_plot, dpi = 100, eval=dedup}

umitools_out <- list.files(path = paste0(dir,"/results/aligned"), pattern = "*out.duprm.log$", recursive = TRUE, full.names = T) %>%
  map(~read_delim(.x, delim="\t", skip = 57, col_names = c("invalue")))

# umitools_out <- map(umitools_out, ~ umitools_out[(length(umitools_out) - 6):length(umitools_out), ])

umitools_out <- map(umitools_out, ~mutate(.x, measure = substr(invalue, 29, nchar(invalue)) %>% strsplit(., split = ":")) )


umitools_out = map(umitools_out, ~mutate(.x,
 measure=modify_if(measure,
                           .p = is_empty,
                           .f = ~NA_character_))
)

umitools_out <- map(umitools_out, ~ rowwise(.x) %>%
  mutate(
    type = measure[[1]],
    number = measure[[length(measure)]]
  ) %>%
  .[(nrow(.) - 5):(nrow(.) - 2), ])

umitools_out_names <-  list.files(path = paste0(dir,"/results/aligned"), pattern = "*out.duprm.log$", recursive = TRUE) %>%
  gsub("chimeric_", "", . ) %>%
  gsub(".Aligned.sortedByCoord.out.duprm.log", "", . )

names(umitools_out) <- umitools_out

umitools_out_2 <- map_dfr(umitools_out, ~.x$number)
umitools_out_2 <- t(umitools_out_2) %>% as.data.frame()

# Keep original short column names for plotting
colnames(umitools_out_2) <- c("uniquely_mapped_reads", "deduplicated_reads", "crosslinked_nucleotides", "mean_events_per_nucleotide")
umitools_out_2$Sample <- umitools_out_names
rownames(umitools_out_2) <- umitools_out_names

# Create display table with nice names and comma formatting
umitools_out_2_display <- umitools_out_2
umitools_out_2_display[,1:3] <- lapply(umitools_out_2_display[,1:3], function(x) format(as.numeric(x), big.mark = ",", scientific = FALSE))
umitools_out_2_display[,4] <- round(as.numeric(umitools_out_2_display[,4]), 2)
colnames(umitools_out_2_display) <- c("Uniquely mapped reads", "Crosslink events (deduplicated reads)", "Crosslinked nucleotides", "Mean crosslink events per crosslinked nucleotide", "Sample")

kable(umitools_out_2_display[,1:4], caption = "Crosslink identification and nucleotide-level resolution statistics") %>% kable_styling(bootstrap_options = "striped", full_width = TRUE) %>% scroll_box(width = "100%")

gg.umitools_out_2 <- umitools_out_2 %>% reshape2::melt(id.vars = c("mean_events_per_nucleotide", "Sample"))
gg.umitools_out_2$value <- as.numeric(gg.umitools_out_2$value)

# Reorder factor levels (reversed for coord_flip)
gg.umitools_out_2$variable <- factor(gg.umitools_out_2$variable, 
                                      levels = c("crosslinked_nucleotides",
                                                "deduplicated_reads", 
                                                "uniquely_mapped_reads"))

p <- ggplot(gg.umitools_out_2, aes(x = Sample, y = value, fill = variable))+
  geom_col(position = "dodge", stat = "identity", color = "black")+
  geom_text(aes(label = scales::comma(value)), 
            position = position_dodge(width = 0.9), 
            hjust = -0.1, 
            size = 7)+
  theme(axis.text.x = element_text(angle = 0, hjust = 0.5),
        axis.text.y = element_text(size = rel(0.9)),
        legend.title= element_blank(),
        legend.position = "top")+
  ylab("Number of reads")+
  xlab("Sample")+
  coord_flip()+
  scale_y_continuous(labels = scales::comma, expand = expansion(mult = c(0, 0.15)))+
  scale_fill_manual(values = unname(racoon_colors[c("crosslinked_nucleotides", "deduplicated_reads", "uniquely_mapped_reads")]),
                    labels = c("Crosslinked Nucleotides",
                              "Crosslink Events (Deduplicated Reads)", 
                              "Uniquely Mapped Reads")) +
  guides(fill = guide_legend(nrow = 2, byrow = TRUE))
print(p)
ggsave(filename = paste0(plots_dir, "/Obtaining_crosslinks.pdf"), plot = p, width = 14, height = 8)

```

```{r peak_calling_header_1, eval=peaks, results='asis'}
cat("# Peak calling \n")
cat("Peaks are called with pureclip on the merged bam files of the sample groups (or all samples if no groups are specified). \n\n")
```

```{r peak_calling_table, eval=peaks, results='asis'}
# Function to count lines in peak bed files
count_peak_lines <- function(peak_dir) {
  # Find all .bed files in the peaks directory
  peak_files <- list.files(path = peak_dir, pattern = "\\.bed$", full.names = TRUE, recursive = TRUE)
  
  if (length(peak_files) == 0) {
    return(data.frame(Group = "No peak files found", Peaks = 0, stringsAsFactors = FALSE))
  }
  
  # Count lines in each file using system wc -l command
  peak_counts <- sapply(peak_files, function(file) {
    if (file.exists(file)) {
      # Use system command wc -l for efficient line counting
      wc_result <- system(paste("wc -l", shQuote(file)), intern = TRUE)
      # Extract the number from the wc output (first element before the filename)
      line_count <- as.numeric(strsplit(trimws(wc_result), "\\s+")[[1]][1])
      return(line_count)
    } else {
      return(0)
    }
  })
  
  # Create a data frame with group names (from filenames without extension) and counts
  peak_summary <- data.frame(
    Group = gsub("\\.bed$", "", basename(names(peak_counts))),
    Peaks = as.numeric(peak_counts),
    stringsAsFactors = FALSE
  )
  
  # Sort by group name
  peak_summary <- peak_summary[order(peak_summary$Group), ]
  rownames(peak_summary) <- NULL
  
  return(peak_summary)
}

# Count peaks if directory exists
peaks_dir <- paste0(dir, "/results/peaks")
if (dir.exists(peaks_dir)) {
  peak_summary <- count_peak_lines(peaks_dir)
  

  cat("Number of peaks identified in each sample/group: \n\n")}
```

```{r peak_table_display, eval=peaks, results='asis'}
if (dir.exists(peaks_dir)) {
  # Create formatted version for display
  peak_summary_display <- peak_summary
  peak_summary_display$Peaks <- format(peak_summary$Peaks, big.mark = ",", scientific = FALSE)
  
  print(kable(as.data.frame(peak_summary_display), caption = "Number of peaks identified by Pureclip for each sample or group") %>% kable_styling(bootstrap_options = "striped", full_width = TRUE))
  
  # Also create a simple bar plot if there are peaks
  if (nrow(peak_summary) > 0 && any(peak_summary$Peaks > 0)) {
    cat("\n\n")
  }
}
```

```{r peak_calling_plot, eval=peaks, dpi=100}
if (dir.exists(peaks_dir) && nrow(peak_summary) > 0 && any(peak_summary$Peaks > 0)) {
    p <- ggplot(peak_summary, aes(x = Group, y = Peaks)) +
      geom_col(fill = unname(racoon_colors["peaks"], alpha = 0.9, stat = "identity", color = "black") +
      geom_text(aes(label = scales::comma(Peaks)), 
                hjust = -0.1, 
                size = 7) +
      theme(axis.text.x = element_text(angle = 0, hjust = 0.5),
            axis.text.y = element_text(size = rel(0.9)),
            legend.title = element_blank()) +
      labs(x = "Sample/Group", y = "Number of Peaks") +
      xlab("Sample/Group") +
      ylab("Number of Peaks") +
      coord_flip() +
      scale_y_continuous(labels = scales::comma, expand = expansion(mult = c(0, 0.15)))
    print(p)
    ggsave(filename = paste0(plots_dir, "/Peak_calling.pdf"), plot = p, width = 14, height = 8)
} else if (dir.exists(peaks_dir)) {
  cat("Peak directory not found. Peaks may not have been called yet or the directory structure may be different. \n\n")
}
```

# Session info

```{r session_info}
sessionInfo()

```



